const express = require("express");
const cors = require("cors");
const path = require("path");

const { createClient } = require("@supabase/supabase-js"); // 🟡 Supabase Admin용

const app = express();
app.use(cors());
app.use(express.json());

// 🟡 gagl.html 요청 시 해당 파일 반환
app.get("/gagl.html", (req, res) => {
    res.sendFile(path.join(__dirname, "gagl.html"));
});

// ✅ Supabase Admin client 설정 (회원탈퇴용, 절대 클라이언트에 노출금지)
const supabaseAdmin = createClient(
    "https://piafesfywtvpachbfoxr.supabase.co", // 프로젝트 URL
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBpYWZlc2Z5d3R2cGFjaGJmb3hyIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0NDc4NDAxOCwiZXhwIjoyMDYwMzYwMDE4fQ.inGkUGNirltn3arVtb3rPvLpzoxK28OCDOx04rAH0EE"           // 서비스 롤 키
);

app.post("/get-user", async (req, res) => {
    const { 유저UID } = req.body;

    if (!유저UID) {
        return res.status(400).json({ 오류: "유저UID 누락" });
    }

    const { data, error } = await supabaseAdmin
        .from("users")
        .select("*")
        .eq("유저UID", 유저UID)
        .single();

    if (error || !data) {
        return res.status(404).json({ 오류: "유저 정보 없음" });
    }

    // // ⭐ 장비목록에서 공격력 총합 계산
    // let 총공격력 = 0;
    // if (Array.isArray(data.장비목록)) {
    //     for (const 장비 of data.장비목록) {
    //         총공격력 += 장비.공격력 || 0;
    //     }
    // }

    // // ⭐ 전직정보에서 값이 1인 항목 개수 세기
    // let 전직카운트 = 1;
    // if (data.전직정보 && typeof data.전직정보 === "object") {
    //     for (const key in data.전직정보) {
    //         if (data.전직정보[key] === 1) {
    //             전직카운트++;
    //         }
    //     }
    // }

    // // ⭐ DB 업데이트 필요 여부 체크
    // let 업데이트필요 = false;
    // const 업데이트값 = {};

    // 레벨공격력이 10이 아닐때인거 수정해야함 적용할거면
    // if (data.레벨공격력 !== 10) {
    //     업데이트필요 = true;
    //     업데이트값.레벨공격력 = 10;
    //     data.레벨공격력 = 10;
    // }

    // // 장비공격력
    // if (data.장비공격력 !== 총공격력) {
    //     업데이트필요 = true;
    //     업데이트값.장비공격력 = 총공격력;
    //     data.장비공격력 = 총공격력; // 최신값 반영
    // }

    // // 전직공격력
    // if (data.전직공격력 !== 전직카운트) {
    //     업데이트필요 = true;
    //     업데이트값.전직공격력 = 전직카운트;
    //     data.전직공격력 = 전직카운트; // 최신값 반영
    // }

    // const 최종공격력 = 최종공격력계산(data);

    // if (data.최종공격력 !== 최종공격력) {
    //     업데이트필요 = true;
    //     업데이트값.최종공격력 = 최종공격력;
    //     data.최종공격력 = 최종공격력; // 최신값 반영
    // }

    // if (업데이트필요) {
    //     const { error: 업데이트오류 } = await supabaseAdmin
    //         .from("users")
    //         .update(업데이트값)
    //         .eq("유저UID", 유저UID);

    //     if (업데이트오류) {
    //         console.error("DB 업데이트 실패:", 업데이트오류);
    //         // 오류 있어도 조회는 계속 진행
    //     }
    // }

    return res.json({ 유저데이터: data });
});

app.post("/attack-normal", async (req, res) => {
    const { 유저데이터 } = req.body;
    const { 유저UID, 현재층: 클라이언트층 } = 유저데이터;
    const 전투로그 = [];
    if (!유저UID) return res.status(400).json({ 오류: "유저UID 누락" });

    const { data: 유저 } = await supabaseAdmin
        .from("users")
        .select("*")
        .eq("유저UID", 유저UID)
        .single();

    let 현재스태미너 = 유저.현재스태미너 ?? 1000;
    if (현재스태미너 <= 0) {
        return res.json({ 결과: "불가", 메시지: "스태미너가 모두 소진되었습니다." });
    }

    const 모래시계개수 = 유저.유물목록?.["모래시계"] || 0;

    // 총 확률 계산 (예: 3개면 0.03%)
    const 확률 = 모래시계개수 * 0.001;

    // 확률 실패 시에만 스태미너 감소
    if (Math.random() > 확률) {
        현재스태미너--;
    }

    유저.스태미너소모총량++;

    const 몬스터 = 일반악마불러오기(클라이언트층 || 1);
    // 유저.조우기록 = 유저.조우기록 || {
    //     일반: 0
    // };
    // 유저.조우기록["일반"]++;

    const 회복전체력 = 유저.남은체력;
    const 추가회복 = 아이언바디회복(유저);
    let 현재턴 = 0;

    if (추가회복 > 0) {
        유저.남은체력 = Math.min(유저.최대체력, 회복전체력 + 추가회복);

        전투로그.push({
            턴: 현재턴,
            타입: "회복",  // 회복 타입 추가
            유저아이디: 유저.유저아이디,
            유저공격력: 유저.공격력,
            유저최종공격력: 유저.최종공격력,
            유저체력: 유저.남은체력,
            유저최대체력: 유저.최대체력,
            몬스터이름: 몬스터.이름,
            몬스터체력: 몬스터.체력,
            몬스터최대체력: 몬스터.체력,
            몬스터방어력: 몬스터.방어력,
            아이콘: ["아이언바디아이콘"],  // 회복 스킬 아이콘
            효과: `${추가회복}`,  // "체력 회복"만 표시
        });
    }
    현재턴++;

    const 전투 = 전투시뮬레이션(유저, 몬스터, 전투로그, 현재턴);

    if (전투.결과 === "패배") {
        const 유저복구 = {
            ...유저,
            남은체력: 유저.최대체력,
            현재스태미너
        };

        await supabaseAdmin.from("users").update({
            남은체력: 유저복구.남은체력,
            현재스태미너,
            현재층: 클라이언트층,
            // 조우기록: 유저.조우기록
        }).eq("유저UID", 유저UID);

        return res.json({
            결과: "패배",
            몬스터,
            유저남은체력: 전투.유저남은체력,
            유저데이터: 유저복구,
            전투로그
        });
    }

    const 보상 = 보상계산(클라이언트층, 유저, 몬스터);
    보상.숙련도 += 인사이트추가숙련도(유저);
    보상.경험치 += Math.floor(보상.경험치 * 인텔리전스추가경험치배율(유저));
    보상.골드 = Math.floor(보상.골드 * 획득금화발굴(유저));

    const 인사이트발동 = 인사이트추가숙련도(유저) > 0;
    const 인텔리전스발동 = 인텔리전스추가경험치배율(유저) > 0;
    const 발굴발동 = 획득금화발굴(유저) > 1;

    const 레벨업 = 레벨업판정(유저.경험치 + 보상.경험치, 유저.레벨);
    const 드레인 = 드레인회복(유저);

    if (드레인 > 0) {
        전투로그.push({
            턴: "종료", // 마지막 전투 턴 그대로 사용
            타입: "회복",
            유저아이디: 유저.유저아이디,
            유저공격력: 유저.공격력,
            유저최종공격력: 유저.최종공격력,
            유저체력: Math.min(유저.최대체력, 전투.유저남은체력 + 드레인),
            유저최대체력: 유저.최대체력,
            몬스터이름: 몬스터.이름,
            몬스터체력: 전투.몬스터남은체력,
            몬스터최대체력: 몬스터.체력,
            몬스터방어력: 몬스터.방어력,
            아이콘: ["드레인아이콘"],  // 드레인 아이콘 표시
            효과: `${드레인}`  // 회복량
        });
    }

    const 새유저 = 전투보상반영(유저, 보상, 드레인, 레벨업, 전투.유저남은체력);
    새유저.현재층 = 클라이언트층;

    const 드랍유물 = 유물드랍판정(몬스터, 유저);
    if (드랍유물) {
        새유저.유물목록 = 새유저.유물목록 || {};
        새유저.유물목록[드랍유물] = (새유저.유물목록[드랍유물] || 0) + 1;
    }

    const 최종공격력 = 최종공격력계산(새유저);
    새유저.최종공격력 = 최종공격력;
    const 최대체력 = 최대체력계산(새유저);
    새유저.최대체력 = 최대체력;

    await supabaseAdmin.from("users").update({
        레벨: 새유저.레벨,
        공격력: 새유저.공격력,
        레벨공격력: 새유저.레벨공격력,
        최종공격력: 최종공격력,
        경험치: 새유저.경험치,
        골드: 새유저.골드,
        최대체력: 새유저.최대체력,
        남은체력: 새유저.남은체력,
        숙련도: 새유저.숙련도,
        현재층: 새유저.현재층,
        스킬: 새유저.스킬,
        // 조우기록: 새유저.조우기록,
        // 조우카운트: 새유저.조우카운트,
        버전업: 새유저.버전업,
        유물목록: 새유저.유물목록,
        현재스태미너,
        스태미너소모총량: 유저.스태미너소모총량,
    }).eq("유저UID", 새유저.유저UID);

    let 레어몬스터이름 = 레어몬스터등장판정(유저);

    return res.json({
        결과: "승리",
        몬스터,
        유저남은체력: 새유저.남은체력,
        보상,
        레벨업,
        회복: 드레인,
        추가골드: 보상.추가골드 || 0,
        추가숙련도: 보상.추가숙련도 || 0,
        유저데이터: {
            ...새유저,
            현재스태미너
        },
        레어몬스터이름,
        전투로그,
        드랍유물,
        스킬발동: {
            인사이트: 인사이트발동,   // true/false
            인텔리전스: 인텔리전스발동, // true/false
            발굴: 발굴발동              // true/false
        }
    });
});

app.post("/attack-rare", async (req, res) => {
    const { 유저데이터, 레어몬스터이름 } = req.body;
    const { 유저UID, 현재층: 클라이언트층 } = 유저데이터;
    const 전투로그 = [];

    if (!유저UID || !레어몬스터이름) {
        return res.status(400).json({ 오류: "입력값 누락" });
    }

    const { data: 유저 } = await supabaseAdmin
        .from("users")
        .select("*")
        .eq("유저UID", 유저UID)
        .single();

    let 현재스태미너 = 유저.현재스태미너 ?? 1000;
    if (현재스태미너 <= 0) {
        return res.json({ 결과: "불가", 메시지: "⚠️ 스태미너가 모두 소진되었습니다." });
    }

    const 모래시계개수 = 유저.유물목록?.["모래시계"] || 0;

    // 총 확률 계산 (예: 3개면 0.03%)
    const 확률 = 모래시계개수 * 0.001;

    // 확률 실패 시에만 스태미너 감소
    if (Math.random() > 확률) {
        현재스태미너--;
    }

    유저.스태미너소모총량++;

    const 몬스터 = 레어악마불러오기(클라이언트층 || 1, 레어몬스터이름);

    // ✅ 조우기록 갱신
    const 타입 = 몬스터.타입 || "";
    유저.조우기록 = 유저.조우기록 || {
        일반: 0,
        레어: 0,
        신화: 0,
        고대: 0,
        태초: 0,
        공허: 0,
        타락: 0,
        황금: 0,
        계시: 0 // 🔥 숙고블린용 타입 추가
    };
    if (유저.조우기록[타입] !== undefined) {
        유저.조우기록[타입]++;
    }

    const 회복전체력 = 유저.남은체력;
    const 추가회복 = 아이언바디회복(유저);
    let 현재턴 = 0;

    if (추가회복 > 0) {
        유저.남은체력 = Math.min(유저.최대체력, 회복전체력 + 추가회복);

        전투로그.push({
            턴: 현재턴,
            타입: "회복",  // 회복 타입 추가
            유저아이디: 유저.유저아이디,
            유저공격력: 유저.공격력,
            유저최종공격력: 유저.최종공격력,
            유저체력: 유저.남은체력,
            유저최대체력: 유저.최대체력,
            몬스터이름: 몬스터.이름,
            몬스터체력: 몬스터.체력,
            몬스터최대체력: 몬스터.체력,
            몬스터방어력: 몬스터.방어력,
            아이콘: ["아이언바디아이콘"],  // 회복 스킬 아이콘
            효과: `${추가회복}`,  // "체력 회복"만 표시
        });
    }
    현재턴++;

    const 전투 = 전투시뮬레이션(유저, 몬스터, 전투로그, 현재턴);

    if (전투.결과 === "패배") {
        const 유저복구 = {
            ...유저,
            남은체력: 유저.최대체력,
            현재스태미너
        };

        await supabaseAdmin.from("users").update({
            남은체력: 유저복구.남은체력,
            현재스태미너,
            현재층: 클라이언트층,
            조우기록: 유저.조우기록
        }).eq("유저UID", 유저UID);

        return res.json({
            결과: "패배",
            몬스터,
            유저남은체력: 전투.유저남은체력,
            유저데이터: 유저복구,
            전투로그
        });
    }

    // ✅ 보상 계산
    const 보상 = 보상계산(클라이언트층, 유저, 몬스터);
    보상.숙련도 += 인사이트추가숙련도(유저);
    보상.경험치 += Math.floor(보상.경험치 * 인텔리전스추가경험치배율(유저));
    보상.골드 = Math.floor(보상.골드 * 획득금화발굴(유저));

    const 인사이트발동 = 인사이트추가숙련도(유저) > 0;
    const 인텔리전스발동 = 인텔리전스추가경험치배율(유저) > 0;
    const 발굴발동 = 획득금화발굴(유저) > 1;

    const 레벨업 = 레벨업판정(유저.경험치 + 보상.경험치, 유저.레벨);
    const 드레인 = 드레인회복(유저);

    if (드레인 > 0) {
        전투로그.push({
            턴: 현재턴, // 마지막 전투 턴 그대로 사용
            타입: "회복",
            유저아이디: 유저.유저아이디,
            유저공격력: 유저.공격력,
            유저최종공격력: 유저.최종공격력,
            유저체력: Math.min(유저.최대체력, 전투.유저남은체력 + 드레인),
            유저최대체력: 유저.최대체력,
            몬스터이름: 몬스터.이름,
            몬스터체력: 전투.몬스터남은체력,
            몬스터최대체력: 몬스터.체력,
            몬스터방어력: 몬스터.방어력,
            아이콘: ["드레인아이콘"],  // 드레인 아이콘 표시
            효과: `${드레인}`  // 회복량
        });
    }

    const 새유저 = 전투보상반영(유저, 보상, 드레인, 레벨업, 전투.유저남은체력);
    새유저.현재층 = 클라이언트층;

    // ✅ 드랍 장비 판정
    const 드랍장비 = 장비드랍판정(몬스터, 유저);
    if (드랍장비) {
        새유저.장비목록 = 새유저.장비목록 || [];
        새유저.합성기록 = 새유저.합성기록 || {};
        const 키 = `${드랍장비.이름}|${드랍장비.등급}`;
        const 기존 = 새유저.장비목록.find(j => j.이름 === 드랍장비.이름 && j.등급 === 드랍장비.등급);

        if (기존) {
            새유저.합성기록[키] = (새유저.합성기록[키] || 0) + 1;
            새유저.최대체력 += 1;
            기존.공격력 += 드랍장비.공격력;
            새유저.장비공격력 += 드랍장비.공격력;
        } else {
            새유저.장비목록.push(드랍장비);
            새유저.합성기록[키] = 0;
            새유저.장비공격력 += 드랍장비.공격력;
        }
    }

    const 드랍유물 = 유물드랍판정(몬스터, 유저);
    if (드랍유물) {
        새유저.유물목록 = 새유저.유물목록 || {};
        새유저.유물목록[드랍유물] = (새유저.유물목록[드랍유물] || 0) + 1;
    }

    const 최종공격력 = 최종공격력계산(새유저);
    새유저.최종공격력 = 최종공격력;
    const 최대체력 = 최대체력계산(새유저);
    새유저.최대체력 = 최대체력;


    await supabaseAdmin.from("users").update({
        레벨: 새유저.레벨,
        공격력: 새유저.공격력,
        레벨공격력: 새유저.레벨공격력,
        장비공격력: 새유저.장비공격력,
        최종공격력: 최종공격력,
        경험치: 새유저.경험치,
        골드: 새유저.골드,
        최대체력: 최대체력,
        남은체력: 새유저.남은체력,
        숙련도: 새유저.숙련도,
        현재층: 새유저.현재층,
        스킬: 새유저.스킬,
        조우기록: 새유저.조우기록,
        합성기록: 새유저.합성기록,
        장비목록: 새유저.장비목록,
        // 조우카운트: 새유저.조우카운트,
        버전업: 새유저.버전업,
        유물목록: 새유저.유물목록,
        스태미너소모총량: 유저.스태미너소모총량,
    }).eq("유저UID", 유저UID);

    let 새로운레어몬스터이름 = 레어몬스터등장판정(유저);

    return res.json({
        결과: "승리",
        몬스터,
        유저남은체력: 새유저.남은체력,
        보상,
        레벨업,
        회복: 드레인,
        드랍장비,
        추가골드: 보상.추가골드 || 0,
        추가숙련도: 보상.추가숙련도 || 0,
        유저데이터: {
            ...새유저,
            현재스태미너
        },
        레어몬스터이름: 새로운레어몬스터이름,
        전투로그,
        드랍유물,
        스킬발동: {
            인사이트: 인사이트발동,   // true/false
            인텔리전스: 인텔리전스발동, // true/false
            발굴: 발굴발동              // true/false
        }
    });
});

app.post("/refresh-stamina", async (req, res) => {
    const { 유저UID } = req.body;
    if (!유저UID) return res.status(400).json({ 오류: "유저UID 누락" });

    // ✅ 현재 한국 시각의 '시간 정수' 계산 (0~23)
    const now = new Date();
    const formatter = new Intl.DateTimeFormat("ko-KR", {
        hour: "numeric",
        hour12: false,
        timeZone: "Asia/Seoul"
    });
    const parts = formatter.formatToParts(now);
    const 현재시간정수 = Number(parts.find(p => p.type === "hour")?.value);

    // ✅ 유저 정보 조회
    const { data: 유저, error } = await supabaseAdmin
        .from("users")
        .select("*")
        .eq("유저UID", 유저UID)
        .single();

    if (error || !유저) return res.status(404).json({ 오류: "유저 정보 없음" });

    const 저장된시간 = 유저.스태미너갱신시간 ?? 현재시간정수;
    let 현재스태미너 = 유저.현재스태미너 ?? 1000;
    const 최대스태미너 = 유저.최대스태미너 ?? 1000;

    // ✅ 시간 차이 계산 (자정 넘을 경우 보정)
    let 시간차이 = 현재시간정수 - 저장된시간;
    if (시간차이 < 0) 시간차이 += 24;

    // ✅ 스태미너 회복량 계산 및 적용
    const 회복량 = 시간차이 * 60;
    현재스태미너 = Math.min(현재스태미너 + 회복량, 최대스태미너);

    // ✅ DB에 반영
    await supabaseAdmin.from("users").update({
        현재스태미너,
        스태미너갱신시간: 현재시간정수
    }).eq("유저UID", 유저UID);

    // ✅ 응답 반환
    return res.json({
        유저데이터: {
            ...유저,
            현재스태미너,
            스태미너갱신시간: 현재시간정수
        }
    });
});

app.post("/upgrade-item", async (req, res) => {
    const { 유저UID, 이름, 등급 } = req.body;

    if (!유저UID || !이름 || !등급) {
        return res.status(400).json({ 오류: "필수 값 누락됨" });
    }

    // 유저 정보 조회
    const { data: 유저, error } = await supabaseAdmin
        .from("users")
        .select("*")
        .eq("유저UID", 유저UID)
        .single();

    if (error || !유저) {
        return res.status(404).json({ 오류: "유저 정보 조회 실패" });
    }

    const 장비목록 = 유저.장비목록 || [];
    const 대상 = 장비목록.find(j => j.이름 === 이름 && j.등급 === 등급);

    if (!대상) {
        return res.status(404).json({ 오류: "장비를 찾을 수 없음" });
    }

    const 강화비용맵 = {
        "일반": 10000,
        "레어": 30000,
        "신화": 100000,
        "고대": 200000,
        "태초": 300000,
        "공허": 400000,
        "타락": 1000000,
    };

    const 강화비용 = 강화비용맵[등급];
    if (typeof 강화비용 !== "number") {
        return res.status(400).json({ 오류: "알 수 없는 등급" });
    }

    if ((유저.골드 || 0) < 강화비용) {
        return res.status(400).json({ 오류: `골드 부족: ${강화비용} 필요` });
    }

    const 모루개수 = 유저.유물목록?.["모루"] || 0;

    let 증가량 = 0;
    let 성공 = Math.random() < (0.61 + 0.001 * 모루개수);
    let 메시지 = "강화 실패..";

    console.log(성공);

    유저.골드 -= 강화비용;

    const 강화증가량맵 = {
        "일반": 5,
        "레어": 15,
        "신화": 30,
        "고대": 80,
        "태초": 150,
        "공허": 240,
        "타락": 600,
    };

    const 단계값 = 강화증가량맵[등급] || 0;

    if (성공) {
        증가량 = 단계값;
        대상.강화 = (대상.강화 || 0) + 1;
        메시지 = `강화 성공! 공격력 +${증가량}`;
    } else {
        if ((대상.강화 || 0) > 0) {
            증가량 = -단계값;
            대상.강화 -= 1;
            메시지 = `강화 실패.. 강화 수치가 1 감소하고 공격력 ${증가량}`;
        } else {
            증가량 = 0;
            메시지 = "강화 실패..";
        }
    }

    대상.공격력 += 증가량;
    유저.공격력 += 증가량;
    유저.장비공격력 += 증가량;

    const 최종공격력 = 최종공격력계산(유저);
    유저.최종공격력 = 최종공격력;

    const { error: 저장오류 } = await supabaseAdmin
        .from("users")
        .update({
            장비목록: 장비목록,
            공격력: 유저.공격력,
            장비공격력: 유저.장비공격력,
            최종공격력: 최종공격력,
            골드: 유저.골드
        })
        .eq("유저UID", 유저UID);

    if (저장오류) {
        return res.status(500).json({ 오류: "강화 결과 저장 실패" });
    }

    return res.json({
        성공,
        증가량,
        강화: 대상.강화,
        공격력: 유저.공격력,
        장비공격력: 유저.장비공격력,
        무기공격력: 대상.공격력, // ✅ 추가!
        최종공격력: 최종공격력,
        골드: 유저.골드,
        메시지
    });

});

app.post("/update-skill", async (req, res) => {
    const { 유저UID, 스킬이름, 행동 } = req.body;

    if (!유저UID || !스킬이름 || !행동) {
        return res.status(400).json({ 오류: "입력값 누락" });
    }

    const { data: 유저, error } = await supabaseAdmin
        .from("users")
        .select("스킬, 숙련도")
        .eq("유저UID", 유저UID)
        .single();

    if (error || !유저) return res.status(404).json({ 오류: "유저 정보 없음" });

    let 스킬 = 유저.스킬 || {};
    let 숙련도 = 유저.숙련도 || 0;

    // ✅ 전체 초기화 요청 분기
    if (스킬이름 === "전체" && 행동 === "초기화") {
        const 총투자 = Object.values(스킬).reduce((a, b) => a + b, 0);
        let 환급 = 0;
        let 투자순번 = 총투자;

        for (let i = 0; i < 총투자; i++) {
            환급 += 투자순번--;
        }

        숙련도 += 환급;
        스킬 = {};

        const { error: 저장오류 } = await supabaseAdmin
            .from("users")
            .update({ 스킬, 숙련도 })
            .eq("유저UID", 유저UID);

        if (저장오류) {
            return res.status(500).json({ 오류: "초기화 저장 실패" });
        }

        return res.json({ 성공: true, 스킬, 숙련도 });
    }

    //스킬갯수수정
    const 스킬정보 = {
        버서커: { 단계: Array(23).fill(0) },
        드레인: { 단계: Array(23).fill(0) },
        발굴: { 단계: Array(5).fill(0) },
        아이언바디: { 단계: Array(23).fill(0) },
        인사이트: { 단계: Array(2).fill(0) },
        크리티컬: { 단계: Array(23).fill(0) },
        버닝: { 단계: Array(23).fill(0) },
        인텔리전스: { 단계: Array(10).fill(0) },
        브로큰: { 단계: Array(23).fill(0) },
    };

    if (!스킬정보[스킬이름]) {
        return res.status(400).json({ 오류: "구현중입니다. 조금만 기다려주세요" });
    }

    const 단계수 = 스킬정보[스킬이름].단계.length;
    const 최대레벨 = 단계수 * 10;
    const 현재레벨 = 스킬[스킬이름] || 0;
    const 총투자 = Object.values(스킬).reduce((a, b) => a + b, 0);

    if (행동 === "투자") {
        if (현재레벨 >= 최대레벨) return res.status(400).json({ 오류: "최종단계입니다" });

        const 투자 = 총투자;
        const 필요한숙련도 = (2 * 투자 + 11) * 5; // 👉 정확한 계산식

        if (숙련도 < 필요한숙련도) return res.status(400).json({ 오류: "숙련도 부족" });

        숙련도 -= 필요한숙련도;
        스킬[스킬이름] = Math.min(현재레벨 + 10, 최대레벨);
    }

    else if (행동 === "회수") {
        if (현재레벨 < 10) return res.status(400).json({ 오류: "회수할 스킬 없음" });

        const 투자 = 총투자;
        const 환급숙련도 = (2 * 투자 - 9) * 5; // 마지막 10단계의 숙련도 합

        숙련도 += 환급숙련도;
        스킬[스킬이름] = 현재레벨 - 10;
    }

    // else if (행동 === "마스터") {
    //     let 레벨 = 현재레벨;
    //     let 투자 = 총투자;

    //     while (레벨 + 10 <= 최대레벨) {
    //         let 필요한숙련도 = 0;

    //         // 다음 10단계에 필요한 숙련도 계산
    //         for (let i = 0; i < 10; i++) {
    //             필요한숙련도 += (2 * (투자 + i) + 11) * 5;
    //         }

    //         // 보유 숙련도가 부족하면 멈춤
    //         if (숙련도 < 필요한숙련도) break;

    //         // 숙련도 차감 및 레벨 증가
    //         숙련도 -= 필요한숙련도;
    //         레벨 += 10;
    //         투자 += 10;
    //     }

    //     if (레벨 === 현재레벨) return res.status(400).json({ 오류: "올릴 수 있는 단계 없음" });

    //     스킬[스킬이름] = 레벨;
    // }


    // else if (행동 === "초기화") {
    //     let 환급 = 0;
    //     let 투자순번 = 총투자;

    //     for (let i = 0; i < 현재레벨; i++) {
    //         환급 += 투자순번--;
    //     }

    //     숙련도 += 환급;
    //     스킬[스킬이름] = 0;
    // }

    else {
        return res.status(400).json({ 오류: "알 수 없는 행동" });
    }

    const { error: 저장오류 } = await supabaseAdmin
        .from("users")
        .update({ 스킬, 숙련도 })
        .eq("유저UID", 유저UID);

    if (저장오류) {
        return res.status(500).json({ 오류: "스킬 저장 실패" });
    }

    return res.json({ 성공: true, 스킬, 숙련도 });
});

app.post("/register-user", async (req, res) => {
    const { 유저UID, 유저아이디, 기기ID, 로그인이메일 } = req.body;

    if (!유저UID || !유저아이디 || !기기ID) {
        return res.status(400).json({ 오류: "입력값 누락" });
    }

    const now = new Date();
    const formatter = new Intl.DateTimeFormat("ko-KR", {
        hour: "numeric",
        hour12: false,
        timeZone: "Asia/Seoul"
    });
    const parts = formatter.formatToParts(now);
    const 현재시간 = Number(parts.find(p => p.type === "hour")?.value);

    //신규유저
    const 삽입값 = {
        유저UID,
        유저아이디,
        로그인이메일,
        기기ID,
        레벨: 1,
        레벨공격력: 10,
        전직공격력: 1,
        최종공격력: 10,
        장비공격력: 0,
        경험치: 0,
        골드: 0,
        최대체력: 10,
        남은체력: 10,
        숙련도: 0,
        현재층: 1,
        현재악마번호: Math.floor(Math.random() * 72) + 1,
        스킬: {},
        조우기록: { 일반: 0, 레어: 0, 신화: 0, 고대: 0, 태초: 0, 공허: 0, 타락: 0 },
        합성기록: {},
        장비목록: [],
        조우카운트: 0,
        강림몬스터: {},
        버전업: 5,
        현재스태미너: 1000,
        최대스태미너: 1000,
        스태미너갱신시간: 현재시간,
        전직정보: {
            "백인장": 0,
            "오백인장": 0,
            "천인장": 0,
            "만인장": 0,
            "부장군": 0,
            "장군": 0,
            "대장군": 0,
            "대사마": 0,
            "승상": 0,
            "후": 0,
            "공": 0,
            "제후": 0,
            "왕": 0,
            "황제": 0,
            "천황": 0,
            "제황": 0,
            "태황": 0,
            "천제": 0
        },
    };

    const { error: 삽입오류 } = await supabaseAdmin
        .from("users")
        .insert(삽입값);

    if (삽입오류) {
        return res.status(500).json({ 오류: "유저 DB 저장 실패" });
    }

    return res.json({ 유저데이터: 삽입값 });
});

app.post("/ranking", async (req, res) => {
    const { 유저UID } = req.body;

    try {
        // 1. 상위 100명 조회
        const { data: 유저들, error } = await supabaseAdmin
            .from("users")
            .select("유저UID, 로그인이메일, 유저아이디, 레벨, 최종공격력, 현재층, 장비목록, 합성기록, 전직정보, 마법의팔레트")
            .eq("버전업", 5)
            .not("최종공격력", "is", null)
            .order("최종공격력", { ascending: false })
            .limit(100);

        if (error) {
            return res.status(500).json({ 오류: "랭킹 조회 실패" });
        }

        for (const 유저 of 유저들) {
            let 팔레트값 = null;

            switch (유저.로그인이메일) {
                case "gagl@gagl.com":
                    팔레트값 = "가글";
                    break;
                case "sibasrigal1@gagl.com":
                    팔레트값 = "블라섬";
                    break;
                case "wlstjr1q2w@gagl.com":
                    팔레트값 = "지옥";
                    break;
                case "Saiha@gagl.com":
                    팔레트값 = "숲";
                    break;

                case "sibasrigal12@gagl.com":
                    팔레트값 = "겨울";
                    break;
                case "johny87@gagl.com":
                    팔레트값 = "겨울";
                    break;
                case "1234qwer@gagl.com":
                    팔레트값 = "겨울";
                    break;
                case "naataa@gagl.com":
                    팔레트값 = "겨울";
                    break;
                case "dus1234@gagl.com":
                    팔레트값 = "겨울";
                    break;
                case "009900@gagl.com":
                    팔레트값 = "겨울";
                    break;
                case "crow@gagl.com":
                    팔레트값 = "겨울";
                    break;
            }

            if (팔레트값 && 유저.마법의팔레트 !== 팔레트값) {
                await supabaseAdmin
                    .from("users")
                    .update({ 마법의팔레트: 팔레트값 })
                    .eq("유저UID", 유저.유저UID);
            }

            유저.직위 = 최고전직명(유저.전직정보) || "";
        }

        return res.json({ 유저들 });
    } catch (e) {
        return res.status(500).json({ 오류: e.message });
    }
});


app.post("/delete-user", async (req, res) => {
    const { 유저UID } = req.body;

    if (!유저UID) {
        return res.status(400).json({ 오류: "UID 누락됨" });
    }

    try {
        // 1. users 테이블 삭제
        const { error: 테이블삭제오류 } = await supabaseAdmin
            .from("users")
            .delete()
            .eq("유저UID", 유저UID);

        if (테이블삭제오류) {
            console.error("유저 테이블 삭제 실패:", 테이블삭제오류.message);
            return res.status(500).json({ 오류: "유저 테이블 삭제 실패" });
        }

        // 2. Supabase Auth 계정 삭제
        const { error: 인증삭제오류 } = await supabaseAdmin.auth.admin.deleteUser(유저UID);

        if (인증삭제오류) {
            console.error("Auth 삭제 실패:", 인증삭제오류.message);
            return res.status(500).json({ 오류: "인증 계정 삭제 실패" });
        }

        return res.json({ 메시지: "유저 데이터 및 인증 삭제 완료" });
    } catch (e) {
        console.error("유저 삭제 중 예외:", e.message);
        return res.status(500).json({ 오류: "서버 예외 발생" });
    }
});

app.post("/update-username", async (req, res) => {
    const { 유저UID, 새아이디 } = req.body;

    if (!유저UID || !새아이디 || 새아이디.length > 8) {
        return res.status(400).json({ 오류: "입력값 누락 또는 길이 초과" });
    }

    // ✅ 이미 존재하는 아이디 있는지 확인
    const { data: 중복, error: 조회오류 } = await supabaseAdmin
        .from("users")
        .select("유저UID")
        .eq("유저아이디", 새아이디)
        .neq("유저UID", 유저UID);

    if (조회오류) {
        return res.status(500).json({ 오류: "중복 확인 실패" });
    }

    if (중복.length > 0) {
        return res.status(409).json({ 오류: "이미 사용 중인 아이디입니다" });
    }

    const { error: 업데이트오류 } = await supabaseAdmin
        .from("users")
        .update({ 유저아이디: 새아이디 })
        .eq("유저UID", 유저UID);

    if (업데이트오류) {
        return res.status(500).json({ 오류: "아이디 변경 실패" });
    }

    return res.json({ 성공: true });
});

app.post("/get-job-info", async (req, res) => {
    const { 유저UID } = req.body;

    if (!유저UID) return res.status(400).json({ 오류: "유저UID 누락" });

    const { data: 유저, error } = await supabaseAdmin
        .from("users")
        .select("전직정보, 경험치")
        .eq("유저UID", 유저UID)
        .single();

    if (error || !유저) return res.status(404).json({ 오류: "유저 정보 없음" });

    return res.json({
        전직정보: 유저.전직정보,
        경험치: 유저.경험치
    });
});

app.post("/promote-job", async (req, res) => {
    const { 유저UID, 직위 } = req.body;

    if (!유저UID || !직위) {
        return res.status(400).json({ 오류: "유저UID 또는 직위 누락" });
    }

    // 유저 정보 불러오기
    const { data: 유저, error } = await supabaseAdmin
        .from("users")
        .select("*")
        .eq("유저UID", 유저UID)
        .single();

    const 전직정보 = 유저.전직정보 ?? {};
    const 완료전직갯수 = Object.values(전직정보).filter(v => v === 1).length;
    const 비용 = (완료전직갯수 + 1) * 50000;

    if (error || !유저) {
        return res.status(404).json({ 오류: "유저 정보 없음" });
    }

    const 경험치 = 유저.경험치 ?? 0;

    if (경험치 < 비용) {
        return res.status(400).json({ 오류: "경험치 부족" });
    }

    if (전직정보[직위] === 1) {
        return res.status(400).json({ 오류: "이미 전직 완료된 직위입니다" });
    }

    전직정보[직위] = 1;

    유저.전직공격력 = 완료전직갯수 + 2;
    const 새레벨 = Math.floor((경험치 - 비용) / 1000) + 1;

    const 새레벨공격력 = 10 + (새레벨 - 1) * 5;
    유저.레벨공격력 = 새레벨공격력;

    const 최종공격력 = 최종공격력계산(유저);
    유저.최종공격력 = 최종공격력;

    const 업데이트 = {
        레벨공격력: 새레벨공격력,
        최종공격력: 최종공격력,
        경험치: 경험치 - 비용,
        레벨: 새레벨,
        전직정보,
        전직공격력: 완료전직갯수 + 2  // ✅ 추가됨
    };

    const { error: 업데이트오류 } = await supabaseAdmin
        .from("users")
        .update(업데이트)
        .eq("유저UID", 유저UID);

    if (업데이트오류) {
        return res.status(500).json({ 오류: "전직 업데이트 실패" });
    }

    return res.json({ 성공: true, 전직정보: 전직정보, 경험치: 경험치 - 비용, 레벨: 새레벨, 최종공격력: 최종공격력 });
});

function 최고전직명(전직정보) {
    const 전직순서 = ["백인장", "오백인장", "천인장", "만인장", "부장군", "장군", "대장군", "대사마", "승상", "후", "공", "제후", "왕", "황제", "천황", "제황", "태황", "천제"];

    let 마지막직위 = null;
    for (const 직위 of 전직순서) {
        if (전직정보?.[직위] === 1) {
            마지막직위 = 직위;
        } else {
            break;
        }
    }
    return 마지막직위;
}

app.post("/gamble", async (req, res) => {
    const { 유저UID, 등급 } = req.body;

    const 비용맵 = {
        "일반": 20000,
        "레어": 40000,
        "신화": 80000,
        "고대": 160000,
        "태초": 320000,
        "공허": 640000,
        "타락": 1280000
    };

    const 장비맵 = {
        "일반": { 이름: "릴리트의 독니", 공격력: 30 },
        "레어": { 이름: "디아블로의 뿔", 공격력: 63 },
        "신화": { 이름: "레비아탄의 비늘", 공격력: 132 },
        "고대": { 이름: "벨제부브의 꼬리", 공격력: 276 },
        "태초": { 이름: "사탄의 날개", 공격력: 576 },
        "공허": { 이름: "바론의 촉수", 공격력: 1200 },
        "타락": { 이름: "루시퍼의 심장", 공격력: 2496 },
    };

    const 비용 = 비용맵[등급];
    const 드랍장비 = 장비맵[등급];
    const 확률 = 0.07;

    if (!비용 || !드랍장비) {
        return res.status(400).json({ 오류: "잘못된 등급" });
    }

    try {
        const { data: 유저, error } = await supabaseAdmin
            .from("users")
            .select("*")
            .eq("유저UID", 유저UID)
            .single();

        if (error || !유저) {
            return res.status(400).json({ 오류: "유저 정보 없음" });
        }

        if (유저.골드 < 비용) {
            return res.status(400).json({ 오류: "골드 부족" });
        }

        const 남은골드 = 유저.골드 - 비용;

        const 천장 = 유저.도박천장 || {};
        const 현재실패 = 천장[등급] || 0;

        const 천장성공 = 현재실패 >= 10;
        const 성공 = 천장성공 || (Math.random() < 확률);

        if (!성공) {
            천장[등급] = 현재실패 + 1;

            await supabaseAdmin
                .from("users")
                .update({
                    골드: Math.max(0, 남은골드),
                    도박천장: 천장  // ✅ 실패 시에도 천장 기록을 저장!
                })
                .eq("유저UID", 유저UID);

            return res.json({
                유저데이터: { ...유저, 골드: 남은골드, 도박천장: 천장 },
                장비: null,
                결과: "실패"
            });
        }


        천장[등급] = 0;
        // 성공 시: 장비 지급 로직
        const 장비목록 = 유저.장비목록 || [];
        const 키 = `${드랍장비.이름}|${등급}`;
        const 기록 = 유저.합성기록 || {};

        let 기존 = 장비목록.find(j => j.이름 === 드랍장비.이름 && j.등급 === 등급);
        let 체력증가량 = 0;

        let 공격력증가량 = 0;

        if (기존) {
            기록[키] = (기록[키] || 0) + 1;
            체력증가량 = 1;
        } else {
            장비목록.push({ 이름: 드랍장비.이름, 등급, 공격력: 드랍장비.공격력, 강화: 0 });
            기록[키] = 0;
            공격력증가량 = 드랍장비.공격력;
        }

        유저.장비공격력 += 공격력증가량;

        const 최종공격력 = 최종공격력계산(유저);
        유저.최종공격력 = 최종공격력;

        const 업데이트 = {
            골드: 남은골드,
            장비목록,
            합성기록: 기록,
            공격력: 유저.공격력 + 공격력증가량,
            최대체력: 유저.최대체력 + 체력증가량,
            장비공격력: 유저.장비공격력,
            최종공격력: 최종공격력,
            도박천장: 천장,
        };

        const { error: 업데이트에러 } = await supabaseAdmin
            .from("users")
            .update(업데이트)
            .eq("유저UID", 유저UID);

        if (업데이트에러) {
            return res.status(500).json({ 오류: "장비 저장 실패" });
        }

        const 유저데이터 = { ...유저, ...업데이트 };

        return res.json({
            유저데이터,
            장비: { ...드랍장비, 등급 },
            결과: "성공"
        });

    } catch (e) {
        return res.status(500).json({ 오류: "서버 오류: " + e.message });
    }
});

app.post("/boss-ranking", async (req, res) => {
    try {
        const { data: 유저들, error } = await supabaseAdmin
            .from("users")
            .select("유저아이디, 보스누적데미지")
            .gt("보스누적데미지", 0) // 👈 0 초과만 필터링
            .order("보스누적데미지", { ascending: false })
            .limit(100);

        if (error) {
            return res.status(500).json({ 오류: "보스 누적 데미지 조회 실패", 상세: error.message });
        }

        res.json({ 순위: 유저들 });
    } catch (e) {
        res.status(500).json({ 오류: "서버 내부 오류", 상세: e.message });
    }
});


app.listen(3000, () => {
    console.log("서버 실행 중: http://localhost:3000");
});

function 공격스킬적용(유저, 현재유저HP) {
    const 스킬 = 유저.스킬 || {};
    const 결과 = {
        크리티컬배율: 1,
        버서커배율: 1,
        버닝배율: 1,
        방어무시율: 0,
        체력소모: 0
    };

    const 크리계열 = [
        { 이름: "알파 크리티컬", 배율: 0.1 },
        { 이름: "베타 크리티컬", 배율: 0.2 },
        { 이름: "감마 크리티컬", 배율: 0.3 },
        { 이름: "델타 크리티컬", 배율: 0.4 },
        { 이름: "엡실론 크리티컬", 배율: 0.5 },
        { 이름: "제타 크리티컬", 배율: 0.6 },
        { 이름: "에타 크리티컬", 배율: 0.7 },
        { 이름: "쎄타 크리티컬", 배율: 0.8 },
        { 이름: "아이오타 크리티컬", 배율: 0.9 },
        { 이름: "카파 크리티컬", 배율: 1.0 },
        { 이름: "람다 크리티컬", 배율: 1.1 },
        { 이름: "뮤 크리티컬", 배율: 1.2 },
        { 이름: "뉴 크리티컬", 배율: 1.3 },
        { 이름: "크사이 크리티컬", 배율: 1.4 },
        { 이름: "오미크론 크리티컬", 배율: 1.5 },
        { 이름: "파이 크리티컬", 배율: 1.6 },
        { 이름: "로 크리티컬", 배율: 1.7 },
        { 이름: "시그마 크리티컬", 배율: 1.8 },
        { 이름: "타우 크리티컬", 배율: 1.9 },
        { 이름: "윕실론 크리티컬", 배율: 2.0 },
        { 이름: "카이 크리티컬", 배율: 2.1 },
        { 이름: "프사이 크리티컬", 배율: 2.2 },
        { 이름: "오메가 크리티컬", 배율: 2.3 }
    ];
    const 크리레벨 = 스킬["크리티컬"] || 0;
    for (let i = 0; i < 크리계열.length; i++) {
        const 시작 = i * 10;
        const 현재 = Math.max(0, Math.min(크리레벨 - 시작, 10));
        if (현재 <= 0) break;
        const 확률 = 현재 >= 10 ? 1 : 현재 * 0.1;
        if (Math.random() < 확률) {
            결과.크리티컬배율 += (크리계열[i].배율);
        } else break;
    }

    // 버서커
    const 버서커계열 = [
        { 이름: "알파 버서커", 배율: 1.2, 소모: 1 },
        { 이름: "베타 버서커", 배율: 1.4, 소모: 1 },
        { 이름: "감마 버서커", 배율: 1.6, 소모: 1 },
        { 이름: "델타 버서커", 배율: 1.8, 소모: 1 },
        { 이름: "엡실론 버서커", 배율: 2.0, 소모: 1 },
        { 이름: "제타 버서커", 배율: 2.2, 소모: 1 },
        { 이름: "에타 버서커", 배율: 2.4, 소모: 1 },
        { 이름: "쎄타 버서커", 배율: 2.6, 소모: 1 },
        { 이름: "아이오타 버서커", 배율: 2.8, 소모: 1 },
        { 이름: "카파 버서커", 배율: 3.0, 소모: 1 },
        { 이름: "람다 버서커", 배율: 3.2, 소모: 1 },
        { 이름: "뮤 버서커", 배율: 3.4, 소모: 1 },
        { 이름: "뉴 버서커", 배율: 3.6, 소모: 1 },
        { 이름: "크사이 버서커", 배율: 3.8, 소모: 1 },
        { 이름: "오미크론 버서커", 배율: 4.0, 소모: 1 },
        { 이름: "파이 버서커", 배율: 4.2, 소모: 1 },
        { 이름: "로 버서커", 배율: 4.4, 소모: 1 },
        { 이름: "시그마 버서커", 배율: 4.6, 소모: 1 },
        { 이름: "타우 버서커", 배율: 4.8, 소모: 1 },
        { 이름: "윕실론 버서커", 배율: 5.0, 소모: 1 },
        { 이름: "카이 버서커", 배율: 5.2, 소모: 1 },
        { 이름: "프사이 버서커", 배율: 5.4, 소모: 1 },
        { 이름: "오메가 버서커", 배율: 5.6, 소모: 1 }
    ];
    const 버서커레벨 = 스킬["버서커"] || 0;
    for (let i = 0; i < 버서커계열.length; i++) {
        const 시작 = i * 10;
        const 현재 = Math.max(0, Math.min(버서커레벨 - 시작, 10));
        if (현재 <= 0) break;
        const 확률 = 현재 >= 10 ? 1 : 현재 * 0.1;
        if (Math.random() < 확률) {
            결과.버서커배율 += 버서커계열[i].배율;
            결과.체력소모 += 버서커계열[i].소모;
        } else break;
    }

    if (현재유저HP < 유저.최대체력 * 0.5) {
        const 버닝레벨 = 스킬["버닝"] || 0;
        const 버닝계열 = [
            { 이름: "알파 버닝", 배율: 0.2 },
            { 이름: "베타 버닝", 배율: 0.4 },
            { 이름: "감마 버닝", 배율: 0.6 },
            { 이름: "델타 버닝", 배율: 0.8 },
            { 이름: "엡실론 버닝", 배율: 1.0 },
            { 이름: "제타 버닝", 배율: 1.2 },
            { 이름: "에타 버닝", 배율: 1.4 },
            { 이름: "쎄타 버닝", 배율: 1.6 },
            { 이름: "아이오타 버닝", 배율: 1.8 },
            { 이름: "카파 버닝", 배율: 2.0 },
            { 이름: "람다 버닝", 배율: 2.2 },
            { 이름: "뮤 버닝", 배율: 2.4 },
            { 이름: "뉴 버닝", 배율: 2.6 },
            { 이름: "크사이 버닝", 배율: 2.8 },
            { 이름: "오미크론 버닝", 배율: 3.0 },
            { 이름: "파이 버닝", 배율: 3.2 },
            { 이름: "로 버닝", 배율: 3.4 },
            { 이름: "시그마 버닝", 배율: 3.6 },
            { 이름: "타우 버닝", 배율: 3.8 },
            { 이름: "윕실론 버닝", 배율: 4.0 },
            { 이름: "카이 버닝", 배율: 4.2 },
            { 이름: "프사이 버닝", 배율: 4.4 },
            { 이름: "오메가 버닝", 배율: 4.6 }
        ];
        for (let i = 0; i < 버닝계열.length; i++) {
            const 시작 = i * 10;
            const 현재 = Math.max(0, Math.min(버닝레벨 - 시작, 10));
            if (현재 <= 0) break;
            const 확률 = 현재 >= 10 ? 1 : 현재 * 0.1;
            if (Math.random() < 확률) {
                결과.버닝배율 += 버닝계열[i].배율;
            } else break;
        }
    }

    // 🟡 브로큰 추가
    const 브로큰레벨 = 스킬["브로큰"] || 0;
    const 브로큰계열 = [
        { 이름: "알파 브로큰", 무시율: 0.01 },
        { 이름: "베타 브로큰", 무시율: 0.0125 },
        { 이름: "감마 브로큰", 무시율: 0.015 },
        { 이름: "델타 브로큰", 무시율: 0.0175 },
        { 이름: "엡실론 브로큰", 무시율: 0.02 },
        { 이름: "제타 브로큰", 무시율: 0.0225 },
        { 이름: "에타 브로큰", 무시율: 0.025 },
        { 이름: "쎄타 브로큰", 무시율: 0.0275 },
        { 이름: "아이오타 브로큰", 무시율: 0.03 },
        { 이름: "카파 브로큰", 무시율: 0.0325 },
        { 이름: "람다 브로큰", 무시율: 0.035 },
        { 이름: "뮤 브로큰", 무시율: 0.0375 },
        { 이름: "뉴 브로큰", 무시율: 0.04 },
        { 이름: "크사이 브로큰", 무시율: 0.0425 },
        { 이름: "오미크론 브로큰", 무시율: 0.045 },
        { 이름: "파이 브로큰", 무시율: 0.0475 },
        { 이름: "로 브로큰", 무시율: 0.05 },
        { 이름: "시그마 브로큰", 무시율: 0.0525 },
        { 이름: "타우 브로큰", 무시율: 0.055 },
        { 이름: "윕실론 브로큰", 무시율: 0.0575 },
        { 이름: "카이 브로큰", 무시율: 0.06 },
        { 이름: "프사이 브로큰", 무시율: 0.0625 },
        { 이름: "오메가 브로큰", 무시율: 0.065 }
    ];

    for (let i = 0; i < 브로큰계열.length; i++) {
        const 시작 = i * 10;
        const 현재 = Math.max(0, Math.min(브로큰레벨 - 시작, 10));
        if (현재 <= 0) break;
        const 확률 = 현재 >= 10 ? 1 : 현재 * 0.1;
        if (Math.random() < 확률) {
            결과.방어무시율 += 브로큰계열[i].무시율;
        } else break;
    }

    return 결과;
}

function 데미지계산(유저, 몬스터, 스킬결과) {
    let 방어력 = 몬스터.방어력 || 0;

    const 쉴드밴개수 = 유저.유물목록?.["쉴드밴"] || 0;
    const 보정 = 1 - 0.01 * 쉴드밴개수;

    if (스킬결과.방어무시율 > 0) {
        방어력 = Math.floor(방어력 * (1 - 스킬결과.방어무시율) * 보정);
    }

    const 랜덤보정 = Math.random() * 0.4 + 0.8;

    const 기본데미지 = Math.max(0, 유저.최종공격력 - 방어력);
    const 랜덤데미지 = Math.floor(기본데미지 * 랜덤보정);

    const 최종배율 = (스킬결과.크리티컬배율) * (스킬결과.버서커배율) * (스킬결과.버닝배율);
    const 최종데미지 = Math.floor(랜덤데미지 * 최종배율);

    return 최종데미지;
}

function 전투시뮬레이션(유저, 몬스터, 전투로그, 시작턴) {
    let 유저HP = 유저.남은체력;

    //하트마이너스
    const 하트마이너스 = 유저.유물목록?.["하트마이너스"] || 0;
    const 보정 = 1 - 0.001 * 하트마이너스;
    몬스터.체력 = Math.floor(몬스터.체력 * 보정);
    let 몬스터HP = 몬스터.체력;
    let 현재턴 = 시작턴;

    while (유저HP > 0 && 몬스터HP > 0) {
        몬스터HP = Math.max(0, 몬스터HP);
        유저HP = Math.max(0, 유저HP);

        유저HP--;
        const 스킬 = 공격스킬적용(유저, 유저HP);
        const 데미지 = 데미지계산(유저, 몬스터, 스킬);
        유저HP -= 스킬.체력소모;

        몬스터HP -= 데미지;
        몬스터HP = Math.max(0, 몬스터HP); // 🔥 여기서 즉시 보정

        const 발동아이콘 = [];
        if (스킬.크리티컬배율 > 1) 발동아이콘.push("크리티컬아이콘");
        if (스킬.버서커배율 > 1) 발동아이콘.push("버서커아이콘");
        if (스킬.버닝배율 > 1) 발동아이콘.push("버닝아이콘");
        if (스킬.방어무시율 > 0) 발동아이콘.push("브로큰아이콘");

        const 쉴드밴개수 = 유저.유물목록?.["쉴드밴"] || 0;
        const 보정 = 1 - 0.01 * 쉴드밴개수;

        const 몬스터방어력계산 = (스킬.방어무시율 > 0)
            ? Math.floor((몬스터.방어력 || 0) * (1 - 스킬.방어무시율) * 보정)
            : Math.floor((몬스터.방어력 || 0) * 보정);

        전투로그.push({
            턴: 현재턴,
            타입: "공격",
            유저아이디: 유저.유저아이디,
            유저공격력: 유저.공격력,
            유저최종공격력: 유저.최종공격력,
            유저체력: 유저HP,
            유저최대체력: 유저.최대체력,
            몬스터이름: 몬스터.이름,
            몬스터체력: 몬스터HP,
            몬스터최대체력: 몬스터.체력,
            몬스터방어력: 몬스터방어력계산,
            아이콘: 발동아이콘,
            효과: `${데미지}`
        });

        현재턴++;
    }

    return {
        결과: 유저HP <= 0 ? "패배" : "승리",
        유저남은체력: 유저HP,
        몬스터남은체력: 몬스터HP
        // 전투로그는 따로 반환 안 해도 됨 (이미 외부 배열에 누적됨)
    };
}

function 장비드랍판정(몬스터, 유저) {
    // if (몬스터.타입 === "일반") return null;

    const 고정드랍 = {
        "일반": { 이름: "릴리트의 독니", 공격력: 30 },
        "레어": { 이름: "디아블로의 뿔", 공격력: 63 },
        "신화": { 이름: "레비아탄의 비늘", 공격력: 132 },
        "고대": { 이름: "벨제부브의 꼬리", 공격력: 276 },
        "태초": { 이름: "사탄의 날개", 공격력: 576 },
        "공허": { 이름: "바론의 촉수", 공격력: 1200 },
        "타락": { 이름: "루시퍼의 심장", 공격력: 2496 },
    };

    const 클로버 = 유저.유물목록?.["클로버"] || 0;
    const 드랍 = 고정드랍[몬스터.타입];
    const 드랍확률 = 0.61 + 0.001 * 클로버;

    if (!드랍 || Math.random() > 드랍확률) return null;

    return {
        이름: 드랍.이름,
        공격력: 드랍.공격력,
        등급: 몬스터.타입,
        강화: 0
    };
}

function 유물드랍판정(몬스터, 유저) {
    // 최대갯수 99개 초과한 유물은 드랍 후보에서 제외
    const 후보유물 = Object.keys(유물데이터).filter(유물이름 => {
        const 보유량 = (유저.유물목록?.[유물이름] || 0);
        return 보유량 < 99;
    });

    const 드랍확률 = 0.008; // 0.8% 예시

    if (후보유물.length > 0 && Math.random() < 드랍확률) {
        const 랜덤유물 = 후보유물[Math.floor(Math.random() * 후보유물.length)];
        return 랜덤유물;
    }

    return null; // 드랍 안됨
}

function 보상계산(층, 유저, 몬스터) {
    let 경험치 = 400;
    let 감소율 = 0.2;
    for (let i = 1; i < 유저.레벨; i++) {
        경험치 *= (1 - 감소율);
        감소율 *= 0.9;
    }

    const 보정계수 = 0.9 + Math.random() * 0.2;
    경험치 = Math.floor(경험치 * 보정계수);

    let 골드 = Math.floor(Math.random() * 100) + (층 - 1) * 100;
    let 숙련도 = Math.floor(층 * 1);

    let 추가골드 = 0;
    let 추가숙련도 = 0;

    if (몬스터.타입 === "황금") {
        추가골드 = 골드 * 49;
        골드 *= 50;
    }

    if (몬스터.타입 === "계시") {
        추가숙련도 = 숙련도 * 49;
        숙련도 *= 50;
    }

    return { 경험치, 골드, 숙련도, 추가골드, 추가숙련도 };
}

function 레벨업판정(현재경험치, 현재레벨) {
    const 새레벨 = Math.floor(현재경험치 / 1000) + 1;

    const 증가량 = 새레벨 - 현재레벨;

    return {
        새레벨,
        증가한레벨: 증가량,
        증가한공격력: 증가량 * 5
    };
}

function 드레인회복(유저) {
    const 스킬 = 유저.스킬 || {};
    const 드레인레벨 = 스킬["드레인"] || 0;

    const 스킬들 = [
        { 이름: "알파 드레인", 회복: 1 },
        { 이름: "베타 드레인", 회복: 1 },
        { 이름: "감마 드레인", 회복: 1 },
        { 이름: "델타 드레인", 회복: 1 },
        { 이름: "엡실론 드레인", 회복: 1 },
        { 이름: "제타 드레인", 회복: 1 },
        { 이름: "에타 드레인", 회복: 1 },
        { 이름: "쎄타 드레인", 회복: 1 },
        { 이름: "아이오타 드레인", 회복: 1 },
        { 이름: "카파 드레인", 회복: 1 },
        { 이름: "람다 드레인", 회복: 1 },
        { 이름: "뮤 드레인", 회복: 1 },
        { 이름: "뉴 드레인", 회복: 1 },
        { 이름: "크사이 드레인", 회복: 1 },
        { 이름: "오미크론 드레인", 회복: 1 },
        { 이름: "파이 드레인", 회복: 1 },
        { 이름: "로 드레인", 회복: 1 },
        { 이름: "시그마 드레인", 회복: 1 },
        { 이름: "타우 드레인", 회복: 1 },
        { 이름: "윕실론 드레인", 회복: 1 },
        { 이름: "카이 드레인", 회복: 1 },
        { 이름: "프사이 드레인", 회복: 1 },
        { 이름: "오메가 드레인", 회복: 1 }
    ];

    let 총회복량 = 0;

    for (let i = 0; i < 스킬들.length; i++) {
        const 시작 = i * 10;
        const 현재레벨 = Math.max(0, Math.min(드레인레벨 - 시작, 10));
        if (현재레벨 <= 0) break;

        const 확률 = 현재레벨 >= 10 ? 1 : 현재레벨 * 0.1;
        if (Math.random() < 확률) {
            총회복량 += 스킬들[i].회복;
        } else break;
    }

    return 총회복량;
}

function 아이언바디회복(유저) {
    const 스킬 = 유저.스킬 || {};
    const 아이언레벨 = 스킬["아이언바디"] || 0;

    const 스킬들 = [
        { 이름: "알파 아이언바디", 회복: 1 },
        { 이름: "베타 아이언바디", 회복: 1 },
        { 이름: "감마 아이언바디", 회복: 1 },
        { 이름: "델타 아이언바디", 회복: 1 },
        { 이름: "엡실론 아이언바디", 회복: 1 },
        { 이름: "제타 아이언바디", 회복: 1 },
        { 이름: "에타 아이언바디", 회복: 1 },
        { 이름: "쎄타 아이언바디", 회복: 1 },
        { 이름: "아이오타 아이언바디", 회복: 1 },
        { 이름: "카파 아이언바디", 회복: 1 },
        { 이름: "람다 아이언바디", 회복: 1 },
        { 이름: "뮤 아이언바디", 회복: 1 },
        { 이름: "뉴 아이언바디", 회복: 1 },
        { 이름: "크사이 아이언바디", 회복: 1 },
        { 이름: "오미크론 아이언바디", 회복: 1 },
        { 이름: "파이 아이언바디", 회복: 1 },
        { 이름: "로 아이언바디", 회복: 1 },
        { 이름: "시그마 아이언바디", 회복: 1 },
        { 이름: "타우 아이언바디", 회복: 1 },
        { 이름: "윕실론 아이언바디", 회복: 1 },
        { 이름: "카이 아이언바디", 회복: 1 },
        { 이름: "프사이 아이언바디", 회복: 1 },
        { 이름: "오메가 아이언바디", 회복: 1 }
    ];

    let 공격전회복량 = 0;

    for (let i = 0; i < 스킬들.length; i++) {
        const 시작 = i * 10;
        const 현재 = Math.max(0, Math.min(아이언레벨 - 시작, 10));
        if (현재 <= 0) break;

        const 확률 = 현재 >= 10 ? 1 : 현재 * 0.1;
        if (Math.random() < 확률) {
            공격전회복량 += 스킬들[i].회복;
        } else break;
    }

    return 공격전회복량;
}

function 인사이트추가숙련도(유저) {
    const 스킬 = 유저.스킬 || {};
    const 인사이트레벨 = 스킬["인사이트"] || 0;

    const 스킬들 = [
        { 이름: "마이크로 인사이트", 추가: 1 },
        { 이름: "나노 인사이트", 추가: 2 },
    ];

    let 추가숙련도 = 0;

    for (let i = 0; i < 스킬들.length; i++) {
        const 시작 = i * 10;
        const 현재 = Math.max(0, Math.min(인사이트레벨 - 시작, 10));
        if (현재 <= 0) break;

        const 확률 = 현재 >= 10 ? 1 : 현재 * 0.1;
        if (Math.random() < 확률) {
            추가숙련도 += 스킬들[i].추가;
        } else break;
    }

    return 추가숙련도;
}

function 인텔리전스추가경험치배율(유저) {
    const 스킬 = 유저.스킬 || {};
    const 인텔리레벨 = 스킬["인텔리전스"] || 0;

    const 스킬들 = [
        { 이름: "알파 인텔리전스", 배율: 0.05 },
        { 이름: "베타 인텔리전스", 배율: 0.10 },
        { 이름: "감마 인텔리전스", 배율: 0.15 },
        { 이름: "델타 인텔리전스", 배율: 0.20 },
        { 이름: "엡실론 인텔리전스", 배율: 0.25 },
        { 이름: "제타 인텔리전스", 배율: 0.30 },
        { 이름: "에타 인텔리전스", 배율: 0.35 },
        { 이름: "쎄타 인텔리전스", 배율: 0.40 },
        { 이름: "아이오타 인텔리전스", 배율: 0.45 },
        { 이름: "카파 인텔리전스", 배율: 0.50 },
        // { 이름: "람다 인텔리전스", 배율: 0.55 },
        // { 이름: "뮤 인텔리전스", 배율: 0.60 },
        // { 이름: "뉴 인텔리전스", 배율: 0.65 },
        // { 이름: "크사이 인텔리전스", 배율: 0.70 },
        // { 이름: "오미크론 인텔리전스", 배율: 0.75 },
        // { 이름: "파이 인텔리전스", 배율: 0.80 },
        // { 이름: "로 인텔리전스", 배율: 0.85 },
        // { 이름: "시그마 인텔리전스", 배율: 0.90 },
        // { 이름: "타우 인텔리전스", 배율: 0.95 },
        // { 이름: "윕실론 인텔리전스", 배율: 1.00 },
        // { 이름: "카이 인텔리전스", 배율: 1.05 },
        // { 이름: "프사이 인텔리전스", 배율: 1.10 },
        // { 이름: "오메가 인텔리전스", 배율: 1.15 }
    ];

    let 추가배율 = 0;

    for (let i = 0; i < 스킬들.length; i++) {
        const 시작 = i * 10;
        const 현재 = Math.max(0, Math.min(인텔리레벨 - 시작, 10));
        if (현재 <= 0) break;

        const 확률 = 현재 >= 10 ? 1 : 현재 * 0.1;
        if (Math.random() < 확률) {
            추가배율 += 스킬들[i].배율;
        } else break;
    }

    return 추가배율; // 예: 0.2 or 0.6 등
}

function 획득금화발굴(유저) {
    const 스킬 = 유저.스킬 || {};
    const 발굴레벨 = 스킬["발굴"] || 0;

    const 스킬들 = [
        { 이름: "루비 발굴", 증가: 0.2 },
        { 이름: "사파이어 발굴", 증가: 0.4 },
        { 이름: "에메랄드 발굴", 증가: 0.6 },
        { 이름: "다이아몬드 발굴", 증가: 0.8 },
        { 이름: "토파즈 발굴", 증가: 1.0 },
    ];

    let 금화배율 = 0;

    for (let i = 0; i < 스킬들.length; i++) {
        const 시작 = i * 10;
        const 현재 = Math.max(0, Math.min(발굴레벨 - 시작, 10));
        if (현재 <= 0) break;

        const 확률 = 현재 >= 10 ? 1 : 현재 * 0.1;
        if (Math.random() < 확률) {
            금화배율 += 스킬들[i].증가;
        } else break;
    }

    return 1 + 금화배율; // 곱셈용
}

function 전투보상반영(유저, 보상, 회복량, 레벨업정보, 전투체력) {
    const 새유저 = { ...유저 };

    새유저.유저UID = 유저.유저UID;
    새유저.경험치 += 보상.경험치;
    새유저.골드 += 보상.골드;
    새유저.숙련도 += 보상.숙련도;

    새유저.레벨 += 레벨업정보.증가한레벨;
    새유저.레벨공격력 += 레벨업정보.증가한공격력;
    새유저.남은체력 = Math.min(
        새유저.최대체력,
        전투체력 + 회복량
    );

    return 새유저;
}

function 일반악마불러오기(층) {
    const 일반몬스터이름 = [
        "디나르", "에리곤", "도레알", "크로셀", "루페스", "벨", "시에르", "세레우스", "버알베리스", "발라크",
        "로노베", "자간", "안드라멜리우스", "니베로스", "에이몬", "라에스", "아라타바", "바티바스", "아몬", "안드로말리우스",
        "바피메트", "오로이아스", "오세", "아미", "데카브리아", "벨리알", "디카리브", "세이르", "오로버스", "무루무르",
        "카이미", "알로세스", "샤르나크", "샤크", "사브낙", "라하브", "말포르스", "하우레스", "피닉스", "부알",
        "푸르카스", "가프", "아스모데우스", "포르카스", "보락스", "글라시아라볼라스", "나베리우스", "아이몬", "프루푸스", "살로스",
        "하프리", "페니악스", "다이몬", "스틸", "마르코시아스", "보트스", "제파르", "엘리고스", "레리어", "베레트",
        "시트리", "구시온", "부에르", "카임", "포르네우스", "부네", "아몬", "마라바스", "푸르손", "말파스",
        "파임", "바르바토스"
    ];

    const 랜덤가중치 = () => (Math.random() * 0.2 + 0.9); // 0.9 ~ 1.1 랜덤

    const 일반목록 = 일반몬스터이름.map((이름, i) => {
        const 기준체력 = 층 === 1 ? 30 : 30 * Math.pow(10, 층 - 1);
        const 기준방어력 = 층 === 1 ? 1 : Math.pow(10, 층 - 1);

        return {
            이름,
            체력: Math.floor(기준체력 * 랜덤가중치()),
            방어력: Math.floor(기준방어력 * 랜덤가중치()),
            타입: "일반"
        };
    });

    const 기준몬스터 = 일반목록[Math.floor(Math.random() * 일반목록.length)];

    return 기준몬스터;
}

function 레어악마불러오기(층, 이름) {
    const 이름맵 = {
        "루시퍼": { 체력계수: 3.4, 방어계수: 1.7, 타입: "타락" },
        "바론": { 체력계수: 3.2, 방어계수: 1.6, 타입: "공허" },
        "사탄": { 체력계수: 2.0, 방어계수: 1.5, 타입: "태초" },
        "벨제부브": { 체력계수: 1.8, 방어계수: 1.4, 타입: "고대" },
        "레비아탄": { 체력계수: 1.6, 방어계수: 1.3, 타입: "신화" },
        "디아블로": { 체력계수: 1.2, 방어계수: 1.1, 타입: "레어" },
        "릴리트": { 체력계수: 1, 방어계수: 1, 타입: "일반" },
        "숙고블린": { 체력계수: 1.4, 방어계수: 1.2, 타입: "계시" },
        "황금고블린": { 체력계수: 0.8, 방어계수: 0.8, 타입: "황금" },
    };

    const 설정 = 이름맵[이름];
    if (!설정) return null;

    const 기준체력 = 층 === 1 ? 30 : 30 * Math.pow(10, 층 - 1);
    const 기준방어력 = 층 === 1 ? 1 : Math.pow(10, 층 - 1);

    const 랜덤가중치 = () => (Math.random() * 0.2 + 0.9);

    return {
        이름,
        체력: Math.floor(기준체력 * 설정.체력계수 * 랜덤가중치()),
        방어력: Math.floor(기준방어력 * 설정.방어계수 * 랜덤가중치()),
        타입: 설정.타입
    };
}

function 최종공격력계산(유저) {
    const 레벨공격력 = 유저.레벨공격력 || 10;
    const 장비공격력 = 유저.장비공격력 || 0;
    const 전직공격력 = 유저.전직공격력 || 1;
    const 소드개수 = 유저.유물목록?.["소드"] || 0;

    const 최종공격력 = (레벨공격력 + 장비공격력) * 전직공격력 * (1 + 0.01 * 소드개수);
    return Math.round(최종공격력);
}

function 최대체력계산(유저) {
    const 합성기록 = 유저.합성기록 || {}; // 또는 새유저.합성기록
    const 총합성횟수 = Object.values(합성기록).reduce((a, b) => a + b, 0);

    const 하트개수 = 유저.유물목록?.["하트플러스"] || 0;
    const 보정 = 1 + 0.01 * 하트개수;
    return Math.round((10 + 총합성횟수) * 보정);
}

function 레어몬스터등장판정(유저) {
    const 고스트개수 = 유저.유물목록?.["고스트"] || 0;
    const 보정 = 1 + 0.01 * 고스트개수; // 고스트 1개당 1% 증가

    if (Math.random() < 보정 * (1 / 6400)) return "루시퍼";
    else if (Math.random() < 보정 * (1 / 3200)) return "바론";
    else if (Math.random() < 보정 * (1 / 1600)) return "사탄";
    else if (Math.random() < 보정 * (1 / 800)) return "벨제부브";
    else if (Math.random() < 보정 * (1 / 400)) return "레비아탄";
    else if (Math.random() < 보정 * (1 / 200)) return "디아블로";
    else if (Math.random() < 보정 * (1 / 100)) return "릴리트";
    else if (Math.random() < 보정 * (1 / 50)) return "숙고블린";
    else if (Math.random() < 보정 * (1 / 50)) return "황금고블린";

    return null;
}

const 유물데이터 = {
    "소드": { 설명: "공격력이 증가합니다" }, //완료
    "하트플러스": { 설명: "체력이 증가합니다" }, //완료
    "고스트": { 설명: "히든몬스터 등장률이 증가합니다" }, //완료
    "쉴드밴": { 설명: "악마들의 방어력을 감소시킵니다" }, //완료
    "하트마이너스": { 설명: "악마들의 체력을 감소시킵니다" }, //완료
    "클로버": { 설명: "장비 드랍율을 증가시킵니다" }, //완료
    "모래시계": { 설명: "스태미너 소모를 무시합니다" }, //완료
    // "모루": { 설명: "장비 강화확률을 증가시킵니다" }, //완료
    // "표창": { 설명: "추가로 공격합니다" },
    // "암포라": { 설명: "숙련도 소모량을 감소시킵니다" },
    // "엑스": { 설명: "최종 데미지를 증가시킵니다" },
    // "퍼즐": { 설명: "미정" },
    // "로켓": { 설명: "미정" },
    // "플라워": { 설명: "미정" },
    // "봄": { 설명: "미정" },
    // "여름": { 설명: "미정" },
    // "가을": { 설명: "미정" },
    // "겨울": { 설명: "미정" }
};

// 🟡 정적 파일 경로 설정
app.use(express.static(path.join(__dirname)));

